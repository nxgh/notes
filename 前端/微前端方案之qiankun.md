## TL;DR

- 为什么需要微前端
  - 需要/不需要微前端的场景
- 为什么不是 iframe
- 方案
  - single-spa: **html-entry**
  - web-components
  - Tencent/wujie: **iframe**
  - umi/qiankun: **single-spa**
  - jd/micro-app: **web-component**
  - efoxTeam(欢聚时代)/EMP: **Webpack5 Module Federation**
  - 字节跳动/Garfish
- 微前端方案需要考虑的问题
- qiankun
  - 什么是 qiankun
  - 路由方案
  - 应用跳转
  - 应用通信
  - 部署
  - 样式隔离
- 子应用划分

## 微前端是什么

本质上，微前端(微服务架构)关注的是如何**解决组织和团队间协作带来的工程问题**

- 空间分离带来的协作问题
- 时间延续带来的升级维护

> 通俗来说，就是在一个web应用中可以独立的运行另一个web应用

微前端的目标：方案上跟使用 iframe 一样简单，同时又解决了 iframe 带来的各种体验上的问题

## 微前端出现的背景

> 任何新技术的产生都是为了解决现有场景和需求下的技术痛点

微前端诞生于 Web 应用日益复杂化的场景中, 随着前端技术的不断进步，新的框架、概念、技术层出不穷，更高应用复杂度、更广的团队规模、更高的性能要求已经成为阻塞业务发展的重要瓶颈

随着 Web 标准的演进，前端工程化也在不断演变，从模块化到组件化在到现在的工程化，但在面对**跨团队大规模开发**、**跨团队企业级应用协作**，现有的分治设计模式仍然显得有心无力。


### 传统 Web 应用的研发模式: SPA、MPA

以 「电商运营平台」举例，对于电商运营而言商品、商家、品牌等都是电商运营平台能力的一部分，而不是独立之间的孤岛, 此时有两种项目设计策略：

1. SPA: 将平台内多个系统放置同一个代码仓库维护
2. MPA: 将系统分为多个仓库维护，在首页聚合所有平台的入口

SPA 的优势与劣势

| 优势                                     | 劣势                       |
| ---------------------------------------- | -------------------------- |
| 统一的权限管控、统一的 Open API 开发能力 | 代码权限管控问题           |
| 更好的代码复用，基础库复用               | 项目构建时间长             |
| 统一的运营管理能力                       | 需求发布相互阻塞           |
| 不同系统可以很好的通信                   | 代码 commit 混乱、分支混乱 |
| 更好的性能                               | 技术体系要求统一           |
| 具备局部更新，无缝的用户体验             | 无法同时灰度多条产品功能   |
| 提前预加载用户下一页的内容               | 代码回滚相互影响           |
|                                          | 错误监控无法细粒度拆分     |

MPA 的优势与劣势

| 优势                                                 | 劣势                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| 可以以项目维度拆分代码，解决权限管控问题             | 用户在使用时体验割裂，会在不同平台间跳转                     |
| 仅构建本项目代码，构建速度快                         | 只能以页面维度拆分，无法拆分至区块部分，只能以业务为维度划分 |
| 可以使用不同的技术体系                               | 多系统同灰度策略困难                                         |
| 不存在同一个仓库维护时的 commit 混乱和分支混乱等问题 | 公共包基础库重复加载                                         |
| 功能灰度互不影响                                     | 不同系统间不可以直接通信                                     |
|                                                      | 公共部分只能每个系统独立实现，同一运维通知困难               |
|                                                      | 产品权限无法进行统一收敛                                     |

大规模 Web 应用在面对高复杂度和涉及团队成员广下无法同时保证  DX（developer experience）和 UX（user experience） 的困境

## 微前端的概念

[Micro Frontends](https://micro-frontends.org/) 官网定义了微前端概念：

> Techniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently.
>
> 构建一个现代 web 应用所需要的技术、策略和方法，具备多个团队独立开发、部署的特性


微前端首先解决的是如何解构巨石应用
>
> 单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用后，随之而来的应用不可维护的问题


微前端概念是从**微服务**概念扩展而来的，摒弃大型单体方式，将前端整体分解为小而简单的块，这些块可以独立开发、测试和部署，同时仍然聚合为一个产品出现在客户面前

微前端的核心价值在于**技术栈无关**

应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合

## 微前端的收益

- 技术栈无关
  
  主框架不限制接入应用的技术栈，微应用具备完全自主权
- 独立开发、独立部署

  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
- 增量升级
- 独立运行时
  每个微应用之间状态隔离，运行时状态不共享



## 需要/不需要微前端的场景: 

需要微前端的场景: 

- 系统本身是需要集成和被集成的
- 旧的系统不能下，新的需求还在来
- 系统需要有一套支持动态插拔的机制
- 系统中的部件具备足够清晰的服务边界

不需要微前端的场景
- 团队具备系统内所有架构组件的话语权
- 团队有足够动力去治理、改造这个系统中的所有组件
- 系统及组织架构上，各部件之间本身就是强耦合、自洽、不可分离的
- 极高的产品体验要求，对任何产品交互上的不一致零容忍


## 为什么不是 iframe 

iframe 最大的问题在于它的**隔离性**无法被突破，无法共享应用间上下文

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享

  - 屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中
  - 外层 iframe 容器要自适应内容高度, 需要在 iframe 里面监听 DOMContentLoaded事件，然后把渲染后的内容高度通过 postMessage 传回给外部

3. 全局上下文完全隔离，内存变量不共享。
  - iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。
5. 缓存，iframe 应用更新上线后系统命中缓存显示旧内容，时间戳或强制刷新

- 对于 4 可以睁一只眼闭一只眼
- 对于 1 可以使用 addEventListener或者做一个本地缓存
- 对于 2 使用 postMessage通信,  但此时主应用与微应用强耦合，微应用中的 UI 渲染全部都是 postMessage和 onmessage监听，还要保证消息时序。主应用不应该关注微应用的实现，主应用与微应用应该保持松耦合。
- 对于 3 nginx 配置到同域名下的子路由然后内部转发，nginx 配置灾难，后台不应该关心前端如何实现

## 子模块划分

微前端拆分其实需要有明确的服务边界划分。如果你的微应用之间存在了过多的交互或者耦合，那你可能就要考虑是不是拆分的粒度过细了。

有一个简单的判断方式，就是看你的微应用在独立打开的情况下，是否能完成一个独立的功能/服务的提交。

## single-spa

主要实现思路：
首先在基座应用中注册所有App的路由，single-spa保存各子应用的路由映射关系，充当微前端控制器Controller。URL响应时，匹配子应用路由并加载渲染子应用




## 参考

- [微前端在美团外卖的实践](https://tech.meituan.com/2020/02/27/meituan-waimai-micro-frontends-practice.html)
- [无界文档](https://wujie-micro.github.io/)
- [micro-app](https://github.com/micro-zoe/micro-app/)
- [字节跳动是如何落地微前端的](https://zhuanlan.zhihu.com/p/415900889)
- [efoxTeam/什么是微前端](https://github.com/efoxTeam/emp/wiki/%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E5%89%8D%E7%AB%AF%E3%80%8B)
- [从场景倒推我们要什么样的微前端体系](https://zhuanlan.zhihu.com/p/386763435)
