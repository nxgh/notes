## 总结

Fiber 

1. 作为架构：React 核心算法的重新实现， v16 的 Reconciler 基于 **Fiber 节点**实现，称为 **Fiber Reconciler**
2. 作为数据结构: 每个 **Fiber 节点** 对应了一个 React Element 保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息
3. 作为动态的工作单元来说，每个`Fiber节点`保存了本次更新中该组件改变的状态、要执行的工作

- `Reconciler`工作的阶段被称为`render`阶段。因为在该阶段会调用组件的`render`方法。
- `Renderer`工作的阶段被称为`commit`阶段。就像你完成一个需求的编码后执行`git commit`提交代码。`commit`阶段会把`render`阶段提交的信息渲染在页面上。
- `render`与`commit`阶段统称为`work`，即`React`在工作中。相对应的，如果任务正在`Scheduler`内调度，就不属于`work`。

##  重构 异步可中断

```js
function render(element, container) {
  // ...
  element.props.children.forEach(child => render(child, dom))
  // ...
}

```

这里的递归使得渲染一旦开始，在整棵 element tree 渲染完成之前程序是不会停止。如果这棵 element tree 过于庞大，它有可能会阻塞主进程太长时间

**我们将渲染工作分成几个小部分，在完成每个单元后，如果需要执行其他操作，我们将让浏览器中断渲染**

```js
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

function performUnitOfWork(nextUnitOfWork) {
  // TODO
}
```

> [`requestIdleCallback`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 
>
> `window.requestIdleCallback()`方法插入一个函数，这个函数将**在浏览器空闲时期被调用**，可以把 `requestIdleCallback` 当作是一个 `setTimeout`

为了组织各个工作单元，我们需要一个新的数据结构：Fiber tree

### Fiber Tree

为每一个 element 分配一个 fiber，而每个 fiber 将成为一个工作单元

假如有以下结构

```jsx
 <div>
    <h1>
      <p />
      <a />
    </h1>
    <h2 />
  </div>
```

对应的 Fiber Tree 结构

<img src="D:\Workspace\build-your-own-react\docs\images\无标题-2022-02-28-1411.png" alt="对应的 Fiber Tree 结构" style="zoom: 20%;" />

设计这个数据结构的目标之一是：使查找下一个工作单元变得更加容易

**每一个 Fiber 都会链接到其第一个子节点 `child`，下一个兄弟姐妹节点`sibling`和其父节点`parent`**

将创建 DOM node 的部分代码抽离处理

```js
function createDom(fiber) {
  const dom = fiber.type == 'TEXT_ELEMENT' ? 
        document.createTextNode('') : 
        document.createElement(fiber.type)

  const isProperty = key => key !== 'children'
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })

  return dom
}
```

在 `render` 中设置 Fiber Tree 的根节点

```js
let nextUnitOfWork = null

function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}

```

当浏览器准备好的时候, 将会调用 `workLoop` 函数，从根节点开始执行 `performUnitOfWork` 

```js
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)

```

`performUnitOfWork` 将为每个 fiber 执行三件事

1. 将 element 添加至 DOM
2. 为 element 的 children 创建 fiber
3. 选出下一个工作单元

```js
function performUnitOfWork(fiber) {
  // 1. 创建一个 node 节点然后将其添加至 DOM
  // 将这个 DOM node 保存在 fiber.dom 属性中以持续跟踪
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }

  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }
  // 2. 为每一个chid创建一个新的 fiber
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null

  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }
    // 将其添加到 Fiber Tree 中，它是 child 还是 sibling ，取决于它是否是第一个 child。
    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }
  // 选出下一个工作单元
  // 首先寻找 child ,其次 sibling ,然后是 parent 的 sibling
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
```

## Render and Commit Phases

当我们在处理一个 React element 时，我们都会添加一个新的节点到 DOM 中，而浏览器在渲染完成整个树之前可能会中断我们的工作。在这种情况下，用户将会看不到完整的 UI。

所以我们需要删除那部分对 DOM 进行修改的代码：

```js 
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
 // if (fiber.parent) {
 //   fiber.parent.dom.appendChild(fiber.dom)
 // }
 //...
}
```

跟踪 Fiber Tree 的根节点

```js
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot
}

let nextUnitOfWork = null
let wipRoot = null
```

一旦完成所有工作（直到没有 `nextUnitOfWork` ），我们便将整个 Fiber Tree 交给 DOM。

```js
function commitRoot() {
  commitWork(wipRoot.child)
  wipRoot = null
}

function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}

function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot
}

let nextUnitOfWork = null
let wipRoot = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }

  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }

  requestIdleCallback(workLoop)
}

requestIdleCallback(workLoop)
```

## 更新或删除节点

将在 `render` 函数上接收到的 `elements` 与我们提交给 DOM 的最后一棵 Fiber Tree 进行比较

在完成 commit 之后，我们需要对「最后一次 commit 到 DOM 的一棵 Fiber Tree」 的引用进行保存。我们称它为 `currentRoot` 。同时我们也对每个 Fiber 添加了一个 `alternate` 属性。这个属性是对旧 Fiber 的链接，这个旧 Fiber 是我们在在上一个 commit phase 向 DOM commit 的 Fiber

```js
function commitRoot() {
  commitWork(wipRoot.child)
	// currentRoot: 最后一次 commit 到 DOM 的一棵 Fiber Tree
  currentRoot = wipRoot
  wipRoot = null
}

function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}

function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}

let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
```

## Reconcile

把 `performUnitOfWork` 中用来创建新 Fiber 的部分代码抽离成一个新的函数 `reconcileChildren` 

在这里我们将会旧 Fibers 与新 elements进行 `reconcile` 

1. 我们使用 `type` 属性对它们进行比较：

2. - 如果老的 Fiber 和新的 element 拥有相同的 type，我们可以保留 DOM 节点并仅使用新的 Props 进行更新。这里我们会创建一个新的 Fiber 来使 DOM 节点与旧的 Fiber 保持一致，而props 与新的 element 保持一致。

   - - 我们还向 Fiber 中添加了一个新的属性 `effectTag` ，这里的值为 `UPDATE` 。为稍后我们将在 commit 阶段使用这个属性。

3. - 如果两者的 `type` 不一样并且有一个新的 element，这意味着我们需要创建一个新的 DOM 节点。

   - - 在这种情况下，我们会用 `PLACEMENT` effect tag 来标记新的 Fiber。

4. - 如果两者的 `type` 不一样，并且有一个旧的 Fiber，我们需要删除旧节点。

   - - 在这种情况下，我们没有新的 Fiber，所以我们会把 `DELETION`effect tag 添加到旧 Fiber 中。

```js
function reconcileChildren(wipFiber, elements) {
  let index = 0
  let oldFiber = wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null

  while (index < elements.length || oldFiber != null) {
    const element = elements[index]
    let newFiber = null

    const sameType = oldFiber && element && element.type == oldFiber.type

    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: 'UPDATE',
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: 'PLACEMENT',
      }
    }
    if (oldFiber && !sameType) {
      oldFiber.effectTag = 'DELETION'
      deletions.push(oldFiber)
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      wipFiber.child = newFiber
    } else if (element) {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }
}

```

## 处理不同类型的变化

```js
function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
```

处理前面定义的各种 `effectTags`

```js
function commitWork(fiber) {
  if (!fiber) {
    return
  }

  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom

  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {
    domParent.appendChild(fiber.dom)
  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {
    updateDom(fiber.dom, fiber.alternate.props, fiber.props)
  } else if (fiber.effectTag === 'DELETION') {
    commitDeletion(fiber, domParent)
  }

  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
```

- `PLACEMENT`：这个 DOM 节点添加到父 Fiber  的节点上
- `DELETION`：删除这个 child
- `UPDATE` ：使用最新的 props 来更新现有的 DOM 节点

```js
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(key => !(key in nextProps) || isNew(prevProps, nextProps)(key))
    .forEach(name => {
      const eventType = name.toLowerCase().substring(2)
      dom.removeEventListener(eventType, prevProps[name])
    })

  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ''
    })

  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

  // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name.toLowerCase().substring(2)
      dom.addEventListener(eventType, nextProps[name])
    })
}
```



## React  15 架构

React v15 架构可分为两层：

- ==Reconciler== （协调器）—— 负责找出变化的组件
- ==Renderer==（渲染器）—— 负责将变化的组件渲染到页面上

每当有更新发生时，**Reconciler**会做如下工作：

- 调用函数组件、或class组件的`render`方法，将返回的JSX转化为虚拟DOM
- 将虚拟DOM和上次更新时的虚拟DOM对比
- 通过对比找出本次更新中变化的虚拟DOM
- 通知**Renderer**将变化的虚拟DOM渲染到页面上

在每次更新发生时，**Renderer**接到**Reconciler**通知，将变化的组件渲染在当前宿主环境。

在**Reconciler**中，`mount`的组件会调用[mountComponent](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L498)，`update`的组件会调用[updateComponent](https://github.com/facebook/react/blob/15-stable/src/renderers/dom/shared/ReactDOMComponent.js#L877)。这两个方法都会递归更新子组件。

由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16ms，用户交互就会卡顿。

## React 16 架构

React16架构可以分为三层：

- **==Scheduler==**（调度器）—— 调度任务的优先级，高优任务优先进入**Reconciler**
- Reconciler（协调器）—— 负责找出变化的组件, 并打上不同的Flags
- Renderer（渲染器）—— 负责将变化的组件渲染到页面上

### Scheduler

由于以下因素，React 放弃了使用 `requestIdleCallback` 作为调度器：

- 浏览器兼容性
- 触发频率不稳定，受很多因素影响

`React`实现了功能更完备的`requestIdleCallback`polyfill。除了在空闲时触发回调的功能外，**Scheduler**还提供了多种调度优先级供任务设置。

### Reconciler

[React16的Reconciler ](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1673)更新工作从递归变成了可以中断的循环过程, `shouldYield`判断当前是否有剩余时间。

> ==异步可中断更新==可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。

```js
/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```

v16 中 **Reconciler**与**Renderer**不再是交替工作。当**Scheduler**将任务交给**Reconciler**后，**Reconciler**会为变化的虚拟DOM打上代表增/删/更新的标记

```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```

> 全部的标记见[这里](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js)

整个**Scheduler**与**Reconciler**的工作都在内存中进行。只有当所有组件都完成**Reconciler**的工作，才会统一交给**Renderer**

### Renderer

**Renderer**根据**Reconciler**为虚拟DOM打的标记，同步执行对应的DOM操作。

## React Fiber

> Fiber(纤程)、与进程(Process)、线程(Thread)、协程(Coroutine) 同为程序执行过程



> ==React Fiber== 是 React 核心算法的重新实现。
> 它的主要特点是**渐进式渲染**: 能够将渲染工作分割成块，并将其分散到多个帧。
> 其他关键特性包括在新的**更新**到来时**暂停**、**中止**或**重用**工作的能力; 为不同类型的更新分配优先级的能力; 以及新的并发方式。
>
> 广义的 Fiber，是一种新架构。为了实现这套架构，React 也在 Virtual DOM 上重建了树和节点结构，叫做 fiber 树和 fiber 节点。

#### Fiber 节点的属性定义

1. 

```js
function FiberNode(tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode,){
  // 作为静态数据结构的属性
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // 用于连接其他Fiber节点形成Fiber树
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  // 作为动态的工作单元的属性
  // 保存本次更新造成的状态改变相关信息
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;
    
  // 保存本次更新会造成的DOM操作
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  // 调度优先级相关
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  // 指向该fiber在另一次更新时对应的fiber
  this.alternate = null;
}
```

多个`Fiber节点` 依靠以下三个属性连接成树

```js
// 指向父级Fiber节点
this.return = null;
// 指向子Fiber节点
this.child = null;
// 指向右边第一个兄弟Fiber节点
this.sibling = null;
```



> 为什么 父级指针叫做`return`而不是`parent`或者`father`呢？
>
> 因为作为一个工作单元，`return`指节点执行完`completeWork`后会返回的下一个节点。子`Fiber节点`及其兄弟节点完成工作后会返回其父级节点，所以用`return`指代父级节点。

## Fiber 与 双缓存

> 双缓冲
>
> *双缓冲*即在内存中创建一个与屏幕绘图区域一致的对象，先将图形绘制到内存中的这个对象上，再一次性将这个对象上的图形拷贝到屏幕上，这样能大大加快绘图的速度。

`React`使用“双缓存”来完成`Fiber树`的构建与替换——对应着`DOM树`的创建与更新

在`React`中最多会同时存在两棵`Fiber树`

- 当前屏幕上显示内容对应的`Fiber树`称为`current Fiber树`
- 正在内存中构建的`Fiber树`称为`workInProgress Fiber树`

`current Fiber树`中的`Fiber节点`被称为`current fiber`，`workInProgress Fiber树`中的`Fiber节点`被称为`workInProgress fiber`，他们通过`alternate`属性连接

```js
currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
```

> `React`应用的根节点通过使`current`指针在不同`Fiber树`的`rootFiber`间切换来完成`current Fiber`树指向的切换。
>
> 即当`workInProgress Fiber树`构建完成交给`Renderer`渲染在页面上后，应用根节点的`current`指针指向`workInProgress Fiber树`，此时`workInProgress Fiber树`就变为`current Fiber树`。
>
> 每次状态更新都会产生新的`workInProgress Fiber树`，通过`current`与`workInProgress`的替换，完成`DOM`更新。

