- `createElement`
- `render` 
- `Concurrent Mode`
- `Fibers`
- `Phases` : `Render` and `Commit`
- `Reconciliation`
- `Function Components`
- `Hooks`

## JSX

```jsx
const element = <h1 title="foo">Hello</h1>

const container = document.querySelector('#root')

ReactDom.render(element, container)		
```

JSX 转换为 JS 代码的过程由 Babel 之类的构建工具来完成

```bash
yarn add @babel/core @babel/cli @babel/plugin-transform-react-jsx -D
```

```bash
 .\node_modules\.bin\babel --plugins @babel/plugin-transform-react-jsx index.jsx
```

输出

```js
const element = React.createElement(
  "h1",
  { title: "foo" },
  "Hello"
);
```

> @babel/plugin-transform-react-jsx 中可以显示的指定需要将 JSX 编译为什么函数调用
>
> preact 中会编译为一个名为 `h` 的函数调用



## createElement

1. `createElement` 作用根据传入的参数创建 `ReactElement` 对象

### ReactElement

`ReactElement` 对象是一个用来承载信息的容器，它挂载了节点的以下信息

1. `type`类型，用于判断如何创建节点
2. `key`和`ref`这些特殊信息
3. `props`新的属性内容
4. `$$typeof`用于确定是否属于`ReactElement`

### 实现

在一个 React Element 中，我们只需关注 `type` 和 `props` 两个属性

- `type` 指代 `ReactElement` 的类型
- `props` 是另一个对象，具有 JSX attributes 中所有键值对, 还有一个特殊的属性 `children`, 通常是一个包含更多 elements 的数组

```js
const createElement = (type, props, ...children) => {
  return {
    type,
    props: { ...props, children },
  }
}	
```

处理非对象类型

> 这里为了简化代码，在没有 `children` 时创建了一个空数组，React 中不会对原始类型进行包装

```js
const createTextElement = text => ({
  type: 'TEXT_ELEMENT',
  props: { nodeValue: text, children: [] },
})

const createElement = (type, props, ...children) => {
  return {
    type,
    props: { 
        ...props,
        children: children.map(child => (typeof child === 'object' ? child : createTextElement(child))) 
    },
  }
}
```

现在实现 `render` 函数，只需要关系向 DOM 中添加内容

```js
function render(element, container) {
  const dom = element.type == 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(element.type)

  const isProperty = key => key !== 'children'

  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })

  element.props.children.forEach(child => render(child, dom))

  container.appendChild(dom)
}

```



### 源码

```js
export function createElement(type, config, children) {
  // ...参数校验
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}
```

- `type` 指代 ReactElement 的类型
  - `HostComponent`,原生 DOM 
  - `ClassComponent`
  - `Symbol`

```js
const ReactElement = function(type, key, ref, self, source, owner, props) {
  const element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner,
  };
  return element;
};

```

- `$$typeof` 标记了该对象是一个 `ReactElement`

> `React.createElement`返回的对象就是`React Element`么
>
```js
 export function isValidElement(object) {
   return (
     typeof object === 'object' &&
     object !== null &&
     object.$$typeof === REACT_ELEMENT_TYPE
   );
 }
```
> `$$typeof === REACT_ELEMENT_TYPE`的非`null`对象就是一个合法的`React Element`

> 区分 `ClassComponent` 和 `FunctionComponent`
>
> React通过`ClassComponent`实例原型上的`isReactComponent`变量判断是否是`ClassComponent`
>

```js
 ClassComponent.prototype.isReactComponent = {};
```



## 总结

- `JSX`是一种描述当前组件内容的数据结构

- `JSX` 不包含 `schedule`、`reconcile`、`render` 的相关信息

  

如下信息就不包括在`JSX`中：

- 组件在更新中的`优先级`
- 组件的`state`
- 组件被打上的用于**Renderer**的`标记`

这些内容都包含在`Fiber节点`中。

在组件`mount`时，`Reconciler`根据`JSX`描述的组件内容生成组件对应的`Fiber节点`。

在`update`时，`Reconciler`将`JSX`与`Fiber节点`保存的数据对比，生成组件对应的`Fiber节点`，并根据对比结果为`Fiber节点`打上`标记`